function [q_eta_hat] = pruning_algorithm2(p_hat,P,eta, k0)
%% function q_eta_hat = pruning_algorithm(I_attack)
% Description:
%              This function is to implement pruning algorithm based on
%              the prediction of attack support generated by detection and
%              localization algorithm
%
%       Inputs:
%          P_hat: [n_meas-by-1] probability of safe node
%              P: [n_meas-by-1] Confidence for each measurement channel, it is probability of agreement. 
%                               Basically, reader can generate confidence by runing trained localization algorithm 
%                                on a big dataset, then calculating #(agree)/#(examples) for each node
%            eta:  (0,1)        reliability/agressivability
%      Outputs:
%              q_eta_hat: {n_meas-by-1] pruned indicator
%   parameters:
%              n_meas: number of measurement nodes
%
% @Written by Yu Zheng, Tallahassee, Florida, Aug. 2020
%

N = length(p_hat);

% calculate probability
P_hat_safe = p_hat(p_hat >0.5);                      
r = pmf_PB(P_hat_safe);                          % Oracle Poission-Binomial pmf
num_safe = length(r);

% check if the localization performance is qualified for pruning
% reference: TSMC paper ( equation (36)
e_vector = zeros(num_safe,1);
for idx = 1:num_safe
    e_vector(idx) = exp(k0-(idx-1));
end
eta_up = 1 - sum(e_vector .* r);

q_eta_hat = zeros(N,1);
if eta_up > 0
    % refine confidence parameter
    eta = max(min(eta, eta_up),0.01);

    % calculate reliable number
    L_eta = reliable_num_attacks(r,eta);


    % pruning operation
    [~,indx] = sort(p_hat.*P,'descend');   % (q_hat \circ P) = P_{T_hat_c}
    idx_eta = indx(1:L_eta);
    q_eta_hat(idx_eta) = 1;
else
    % Otherwise, don't use pruning algorihm
    q_eta_hat(p_hat<0.5) = 0;
    q_eta_hat(p_hat>=0.5)= 1;
end
    

end